@prefix : <http://example.org/> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix odrl: <http://www.w3.org/ns/odrl/2/> .
@prefix report: <https://w3id.org/force/compliance-report#> .
@prefix temp: <http://example.com/request/> .
@prefix sotw: <https://w3id.org/force/sotw#> .

# Constraint report

# Connect constraint Report to Rule Report
{ 
    ?rule odrl:constraint ?constraint.
    ?ruleReport report:rule ?rule .
    ?premiseReport report:constraint ?constraint .
} => { 
    ?ruleReport report:premiseReport ?premiseReport .
}.

# Creates a premiseReport for each constraint there is (starting from a rule)
{
    _:a odrl:constraint ?constraint .
    ( ?constraint ) :getUUID ?premiseReport .

} => { 
    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint .
}.

# Creates a premiseReport for each constraint there is (starting from a logical operator)
{
    _:a ?logicaloperand ?constraint .
    ?logicaloperand list:in ( odrl:or odrl:xone odrl:and odrl:andSequence ) .

    ( ?constraint ) :getUUID ?premiseReport .
} => {
    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint .
} .
#######################################################################################################################
# Left Operand Conversion

# odrl:dateTime to xsd:dateTime
# https://www.w3.org/TR/odrl-vocab/#term-dateTime
{
    # bind created premiseReport
    ?premiseReport report:constraint ?constraint .

    ?constraint odrl:leftOperand odrl:dateTime .
    temp:currentTime dct:issued ?dateTime .

    # TODO: check whether rightoperand is xsd:dateTime -> Not here; SHACL validation of constraints

} => { 
    ?premiseReport report:constraintLeftOperand ?dateTime .
}.

# Other ODRL constraint Left operands
# Create empty premise report for leftOperands (no leftOperand present in the evaluation request)
{ 
    # acceptable ODRL Left Operands
    ?leftOperand list:in ( odrl:absolutePosition odrl:absoluteSize odrl:absoluteSpatialPosition odrl:absoluteTemporalPosition odrl:count odrl:delayPeriod odrl:deliveryChannel odrl:device odrl:elapsedTime odrl:event odrl:fileFormat odrl:industry odrl:language odrl:media odrl:meteredTime odrl:payAmount odrl:percentage odrl:product odrl:purpose odrl:recipient odrl:relativePosition odrl:relativeSize odrl:relativeSpatialPosition odrl:relativeTemporalPosition odrl:resolution odrl:spatial odrl:spatialCoordinates odrl:system odrl:systemDevice odrl:timeInterval odrl:unitOfCount odrl:version odrl:virtualLocation ) . 
    
    # check for number of leftOperands in evaluation request
    (
        ?template
        {
            ?requestPermission sotw:context ?requestContextConstraint .
            ?requestContextConstraint odrl:leftOperand ?leftOperand .        
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    # number of leftOperands in evaluation request is 0
    ?L list:length 0 .

    # a rule with a leftOperand constraint
    _:a odrl:constraint ?constraint .
    ?constraint odrl:leftOperand ?leftOperand .
    
    # created premiseReport
    ?premiseReport report:constraint ?constraint .
} => {
    ?premiseReport report:constraintLeftOperand "" . #TODO: do we need a default null left operand value?
}.

# Create empty premise report for leftOperands (one present in the evaluation request)
{ 
    # acceptable ODRL Left Operands
    ?leftOperand list:in ( odrl:absolutePosition odrl:absoluteSize odrl:absoluteSpatialPosition odrl:absoluteTemporalPosition odrl:count odrl:delayPeriod odrl:deliveryChannel odrl:device odrl:elapsedTime odrl:event odrl:fileFormat odrl:industry odrl:language odrl:media odrl:meteredTime odrl:payAmount odrl:percentage odrl:product odrl:purpose odrl:recipient odrl:relativePosition odrl:relativeSize odrl:relativeSpatialPosition odrl:relativeTemporalPosition odrl:resolution odrl:spatial odrl:spatialCoordinates odrl:system odrl:systemDevice odrl:timeInterval odrl:unitOfCount odrl:version odrl:virtualLocation ) . 
    

    ?requestPermission sotw:context ?requestContextConstraint .
    ?requestContextConstraint odrl:leftOperand ?leftOperand .
    ?requestContextConstraint odrl:rightOperand ?requestedPurpose .

    # check for number of leftOperands in evaluation request
    (
        ?template
        {
            ?requestPermission sotw:context ?requestContextConstraint .
            ?requestContextConstraint odrl:leftOperand ?leftOperand .
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    # number of leftOperands in evaluation request is 1
    ?L list:length 1 .

    # a rule with a purpose constraint
    _:a odrl:constraint ?constraint .
    ?constraint odrl:leftOperand ?leftOperand .
    
    # created premiseReport
    ?premiseReport report:constraint ?constraint .
} => {
    ?premiseReport report:constraintLeftOperand ?requestedPurpose . 
}.


#######################################################################################################################
# Comparing the operators using the different odrl operators
# Ordered operators

# Less than: odrl:lt
{ 
    ?constraint 
        odrl:operator odrl:lt ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:lessThan ?rightOperand .

} =>
{
    ?premiseReport 
        report:constraintOperator odrl:lt ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Greater than: odrl:gt
{ 
    ?constraint 
        odrl:operator odrl:gt ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:greaterThan ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:gt ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .

# Equal to: odrl:eq
# Recommendation by Jos on 03/10/2025: equality is difficult. Use both math:equalTo and log:equalTo
# OR operator does not exist in N3, so that's why you have to do it like this
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:equalTo
{ 
    ?constraint 
        odrl:operator odrl:eq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:equalTo ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:eq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .

# https://w3c.github.io/N3/reports/20230703/builtins.html#log:equalTo
{ 
    ?constraint 
        odrl:operator odrl:eq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand log:equalTo ?rightOperand .

} =>
{
    ?premiseReport 
        report:constraintOperator odrl:eq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .

# Greater than or equal to: odrl:gteq
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:notLessThan
{ 
    ?constraint 
        odrl:operator odrl:gteq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:notLessThan ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:gteq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Less than or equal to: odrl:lteq
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:notGreaterThan
{ 
    ?constraint 
        odrl:operator odrl:lteq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:notGreaterThan ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:lteq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Not equal to: odrl:neq
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:notEqualTo
{ 
    ?constraint 
        odrl:operator odrl:neq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:notEqualTo ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:neq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .

# Set-based Operators
# Is any of: odrl:isAnyOf
# There is a right operand value that equals the value that is actually present (through the sotw or evaluation request)
# https://w3c.github.io/N3/reports/20230703/builtins.html#log:equalTo
{
    ?constraint 
        odrl:operator odrl:isAnyOf ;
        odrl:rightOperand ?rightOperand .
    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand log:equalTo ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:isAnyOf ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Is an instance of: odrl:isA
{
    ?constraint 
        odrl:operator odrl:isA ;
        odrl:rightOperand ?rightOperand .
    
    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .
	?leftOperand a ?instance .
  
    ?instance log:equalTo ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:isA ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Is none of: odrl:isNoneOf
{
    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .
    ?constraint odrl:operator odrl:isNoneOf .
    # Verify that there are no matches between the right operand value and the value that is actually present (through the sotw or evaluation request)
    (
        ?template
        {
        ?constraint odrl:rightOperand ?rightOperand .
        ?leftOperand log:equalTo ?rightOperand .
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    ?L list:length 0 .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:isNoneOf ;
        report:satisfactionState report:Satisfied .
} .
# Make set-based reports complete by logging the remainder
{
    ?premiseReport report:constraintOperator ?operator ;
        report:constraint ?constraint .
    ?operator list:in ( odrl:isAnyOf odrl:isNoneOf) .
    ?constraint odrl:rightOperand ?rightOperand .
} => {
    ?premiseReport report:constraintRightOperand ?rightOperand .
} . 
#######################################################################################################################
# Logical operands
# logical operand premisereport generation
{ 
    # match and constraint
    ?constraint a odrl:LogicalConstraint;
       ?operandType ?otherConstraint .
    
    ?operandType list:in ( odrl:and odrl:or odrl:xone odrl:andSequence) .
    # create uuid
    ( ?constraint ) :getUUID ?logicalConstraintReportID .

    # I think the below rule might be troublesome in the future (with uc policies having reports themselves)

} => { 
    ?logicalConstraintReportID a report:ConstraintReport .
    ?logicalConstraintReportID report:constraint ?constraint .

    # Again, I don't think I can do it without explanation
    ?logicalConstraintReportID report:constraintLogicalOperand ?operandType .
}.

# connect logical operand constraints with other premise reports
{ 
    ?logicalConstraintReportID a report:ConstraintReport .
    ?logicalConstraintReportID report:constraint ?constraint .

    ?constraint ?operandType ?otherConstraint.
    ?operandType list:in ( odrl:and odrl:or odrl:xone odrl:andSequence) .

    ?otherConstraintReportID report:constraint ?otherConstraint.
} => {
    ?logicalConstraintReportID report:premiseReport ?otherConstraintReportID  .
} .

# Is and constraint report satisfied? (same for andsequence if you ask me)
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand ?operandType .
    ?operandType list:in ( odrl:and odrl:andSequence) .

    
    # check for number of constraint reports
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport _:s 
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    ?L list:length ?numberConstraints .

    # check for satisfied constraints
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:equalTo ?numberConstraints .  
    # TODO: when there are none satisfied, this is equal -> There is a need for other constraints to be unsatisfiable too (which is not the case yet) 
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Satisfied  .

}.
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand ?operandType .
    ?operandType list:in ( odrl:and odrl:andSequence) .
    
    # check for number of constraint reports
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport _:s 
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    ?L list:length ?numberConstraints .

    # check for satisfied constraints
    (
        ?premiseReport
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:notEqualTo ?numberConstraints .    
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Unsatisfied  .
}.

# Is or constraint report satisfied?
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand odrl:or .
    
    # check for satisfied constraints: At least on of them MUST be satisfied
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints math:notLessThan 1 .  
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Satisfied  .

}.
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand odrl:or .
    
    # check for satisfied constraints: At least on of them MUST be satisfied
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:equalTo 0 .  
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Unsatisfied  .

}.
# is xone premise report satisfied? only one, and not more, of the Constraints MUST be satisfied
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand odrl:xone .
    
    # check for satisfied constraints: At least on of them MUST be satisfied
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:equalTo 1 .  
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Satisfied  .

}.
#######################################################################################################################