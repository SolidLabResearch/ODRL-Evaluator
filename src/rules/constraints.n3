@prefix : <http://example.org/> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix odrl: <http://www.w3.org/ns/odrl/2/> .
@prefix report: <https://w3id.org/force/compliance-report#> .
@prefix temp: <http://example.com/request/> .
@prefix sotw: <https://w3id.org/force/sotw#> .

# Constraint report

# Connect constraint Report to Rule Report
{ 
    ?rule odrl:constraint ?constraint.
    ?ruleReport report:rule ?rule .
    ?premiseReport report:constraint ?constraint .
} => { 
    ?ruleReport report:premiseReport ?premiseReport .
}.

# Creates a premiseReport for each constraint there is.
{
    _:a odrl:constraint ?constraint .
    ( ?constraint ) :getUUID ?premiseReport .

} => { 
    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint .
}.

#######################################################################################################################
# Left Operand Conversion

# odrl:dateTime to xsd:dateTime
# https://www.w3.org/TR/odrl-vocab/#term-dateTime
{
    # bind created premiseReport
    ?premiseReport report:constraint ?constraint .

    ?constraint odrl:leftOperand odrl:dateTime .
    temp:currentTime dct:issued ?dateTime .

    # TODO: check whether rightoperand is xsd:dateTime -> Not here; SHACL validation of constraints

} => { 
    ?premiseReport report:constraintLeftOperand ?dateTime .
}.
# TODO: odrl:dateTime to xsd:date
# https://www.w3.org/TR/odrl-vocab/#term-dateTime
# TODO: check whether rightoperand is xsd:date

# odrl:purpose
# https://www.w3.org/TR/odrl-vocab/#term-purpose
# Create empty premise report for purposes (no purpose present in the evaluation request)
{ 
    # check for number of purposes in evaluation request
    (
        ?template
        {
            ?requestPermission sotw:context ?requestContextConstraint .
            ?requestContextConstraint odrl:leftOperand odrl:purpose .        
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    # number of purposes in evaluation request is 0
    ?L list:length 0 .

    # a rule with a purpose constraint
    _:a odrl:constraint ?constraint .
    ?constraint odrl:leftOperand odrl:purpose .
    
    # created premiseReport
    ?premiseReport report:constraint ?constraint .
} => {
    ?premiseReport report:constraintLeftOperand "" . #TODO: do we need a default purpose?
}.

# Create empty premise report for purposes (one present in the evaluation request)
{ 
    ?requestPermission sotw:context ?requestContextConstraint .
    ?requestContextConstraint odrl:leftOperand odrl:purpose .
    ?requestContextConstraint odrl:rightOperand ?requestedPurpose .

    # check for number of purposes in evaluation request
    (
        ?template
        {
            ?requestPermission sotw:context ?requestContextConstraint .
            ?requestContextConstraint odrl:leftOperand odrl:purpose .
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    # number of purposes in evaluation request is 1
    ?L list:length 1 .

    # a rule with a purpose constraint
    _:a odrl:constraint ?constraint .
    ?constraint odrl:leftOperand odrl:purpose .
    
    # created premiseReport
    ?premiseReport report:constraint ?constraint .
} => {
    ?premiseReport report:constraintLeftOperand ?requestedPurpose . 
}.


#######################################################################################################################
# Comparing the operators using the different odrl operators
# Less than: odrl:lt
{ 
    ?constraint 
        odrl:operator odrl:lt ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:lessThan ?rightOperand .

} =>
{
    ?premiseReport 
        report:constraintOperator odrl:lt ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Greater than: odrl:gt
{ 
    ?constraint 
        odrl:operator odrl:gt ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:greaterThan ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:gt ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .

# Equal to: odrl:eq
# Recommendation by Jos on 03/10/2025: equality is difficult. Use both math:equalTo and log:equalTo
# OR operator does not exist in N3, so that's why you have to do it like this
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:equalTo
{ 
    ?constraint 
        odrl:operator odrl:eq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:equalTo ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:eq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .

# https://w3c.github.io/N3/reports/20230703/builtins.html#log:equalTo
{ 
    ?constraint 
        odrl:operator odrl:eq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand log:equalTo ?rightOperand .

} =>
{
    ?premiseReport 
        report:constraintOperator odrl:eq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .

# Greater than or equal to: odrl:gteq
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:notLessThan
{ 
    ?constraint 
        odrl:operator odrl:gteq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:notLessThan ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:gteq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Less than or equal to: odrl:lteq
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:notGreaterThan
{ 
    ?constraint 
        odrl:operator odrl:lteq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:notGreaterThan ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:lteq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Not equal to: odrl:neq
# https://w3c.github.io/N3/reports/20230703/builtins.html#math:notEqualTo
{ 
    ?constraint 
        odrl:operator odrl:neq ;
        odrl:rightOperand ?rightOperand .

    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand math:notEqualTo ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:neq ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Is any of: odrl:isAnyOf
# There is a right operand value that equals the value that is actually present (the materialized left operand)
# https://w3c.github.io/N3/reports/20230703/builtins.html#log:equalTo
{
    ?constraint 
        odrl:operator odrl:isAnyOf ;
        odrl:rightOperand ?rightOperand .
    ?premiseReport a report:ConstraintReport ;
        report:constraint ?constraint ;
        report:constraintLeftOperand ?leftOperand .

    ?leftOperand log:equalTo ?rightOperand .
} =>
{
    ?premiseReport 
        report:constraintOperator odrl:isAnyOf ;
        report:constraintRightOperand ?rightOperand ;
        report:satisfactionState report:Satisfied .
} .
# Make it complete by logging the remainder
{
    ?premiseReport  report:constraintOperator odrl:isAnyOf ;
        report:constraint ?constraint .
    ?constraint odrl:rightOperand ?rightOperand .
} => {
    ?premiseReport report:constraintRightOperand ?rightOperand .
} . 
#######################################################################################################################
# Logical operands
# logical operand premisereport generation
{ 
    # match and constraint
    ?constraint a odrl:LogicalConstraint;
       ?operandType?otherConstraint .
    
    ?operandType list:in ( odrl:and odrl:or odrl:xone odrl:andSequence) .
    # create uuid
    ( ?constraint ) :getUUID ?logicalConstraintReportID .

    # I think the below rule might be troublesome in the future (with uc policies having reports themselves)

} => { 
    ?logicalConstraintReportID a report:ConstraintReport .
    ?logicalConstraintReportID report:constraint ?constraint .

    # Again, I don't think I can do it without explanation
    ?logicalConstraintReportID report:constraintLogicalOperand ?operandType .
}.

# connect logical operand constraints with other premise reports
{ 
    ?logicalConstraintReportID a report:ConstraintReport .
    ?logicalConstraintReportID report:constraint ?constraint .

    ?constraint ?operandType ?otherConstraint.
    ?operandType list:in ( odrl:and odrl:or odrl:xone odrl:andSequence) .

    ?otherConstraintReportID report:constraint ?otherConstraint.
} => {
    ?logicalConstraintReportID report:premiseReport ?otherConstraintReportID  .
} .

# Is and constraint report satisfied? (same for andsequence if you ask me)
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand ?operandType .
    ?operandType list:in ( odrl:and odrl:andSequence) .

    
    # check for number of constraint reports
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport _:s 
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    ?L list:length ?numberConstraints .

    # check for satisfied constraints
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:equalTo ?numberConstraints .  
    # TODO: when there are none satisfied, this is equal -> There is a need for other constraints to be unsatisfiable too (which is not the case yet) 
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Satisfied  .

}.
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand ?operandType .
    ?operandType list:in ( odrl:and odrl:andSequence) .
    
    # check for number of constraint reports
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport _:s 
        }
        ?L
    ) log:collectAllIn ?SCOPE .
    ?L list:length ?numberConstraints .

    # check for satisfied constraints
    (
        ?premiseReport
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:notEqualTo ?numberConstraints .    
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Unsatisfied  .
}.

# Is or constraint report satisfied?
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand odrl:or .
    
    # check for satisfied constraints: At least on of them MUST be satisfied
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints math:notLessThan 1 .  
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Satisfied  .

}.
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand odrl:or .
    
    # check for satisfied constraints: At least on of them MUST be satisfied
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:equalTo 0 .  
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Unsatisfied  .

}.
# is xone premise report satisfied? only one, and not more, of the Constraints MUST be satisfied
{ 
    ?logicalConstraintReportID a report:ConstraintReport ;
        report:constraintLogicalOperand odrl:xone .
    
    # check for satisfied constraints: At least on of them MUST be satisfied
    (
        ?template
        {
            ?logicalConstraintReportID report:premiseReport ?premiseReport .
            ?premiseReport report:satisfactionState report:Satisfied .
        }
        ?list
    ) log:collectAllIn ?SCOPE .
    ?list list:length ?satisfiedConstraints .
    ?satisfiedConstraints log:equalTo 1 .  
} => { 
    ?logicalConstraintReportID report:satisfactionState report:Satisfied  .

}.
#######################################################################################################################